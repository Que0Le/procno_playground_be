from typing import TYPE_CHECKING

from sqlalchemy import Boolean, Column, Integer, String, DateTime, ForeignKey
from sqlalchemy.orm import relationship

from app.db.base_class import Base

# if TYPE_CHECKING:
#     from .item import Item  # noqa: F401

class AnswerDB(Base):
    # overwrite the tabble name
    __tablename__  = 'answers'

    id = Column(Integer, primary_key=True, index=True)
    owner_id = Column(Integer, ForeignKey("users.id"))
    commentar_id = Column(Integer, ForeignKey("commentars.id"))
    record_id = Column(Integer, ForeignKey("records.id"))
    created_at = Column(DateTime(), nullable=False)
    updated_at = Column(DateTime(), nullable=False)

    def to_string(self):
        return str(
            f"TagDB:\nid[{str(self.id)}]\n\
            owner_id[{str(self.owner_id)}]\n\
            commentar_id[{str(self.commentar_id)}]\n\
            record_id[{str(self.record_id)}]\n\
            created_at[{str(self.created_at)}]\n\
            updated_at[{str(self.updated_at)}]")

class AnswerCombiDB(Base):
    # overwrite the tabble name
    __tablename__  = '__none__'
    # Fake PK and indexed, cause this table is temp and generated by SQL query
    a_id = Column(Integer, primary_key=True, index=True)    
    a_created_at = Column(DateTime(), nullable=False)
    a_updated_at = Column(DateTime(), nullable=False)
    rc_filename = Column(String)
    rc_created_at  = Column(DateTime(), nullable=False)
    rc_updated_at  = Column(DateTime(), nullable=False)
    c_commentar = Column(String)
    c_created_at  = Column(DateTime(), nullable=False)
    c_updated_at  = Column(DateTime(), nullable=False)

    def to_string(self):
        return str(
            f"TagDB:\na_id[{str(self.a_id)}]\n\
            a_created_at[{str(self.a_created_at)}]\n\
            a_updated_at[{str(self.a_updated_at)}]\n\
            rc_filename[{str(self.rc_filename)}]\n\
            rc_created_at[{str(self.rc_created_at)}]\n\
            rc_updated_at[{str(self.rc_updated_at)}]\n\
            c_commentar[{str(self.c_commentar)}]\n\
            c_created_at[{str(self.c_created_at)}]\n\
            c_updated_at[{str(self.c_updated_at)}]")

    def to_json(self):
        return {
            "a_id": self.a_id,
            "a_created_at": self.a_created_at,
            "a_updated_at": self.a_updated_at,
            "rc_filename": self.rc_filename,
            "rc_created_at": self.rc_created_at,
            "rc_updated_at": self.rc_updated_at,
            "c_commentar": self.c_commentar,
            "c_created_at": self.c_created_at,
            "c_updated_at": self.c_updated_at
        }
    #TODO: add more function to decide what to return to the client (exclude internal id ...)